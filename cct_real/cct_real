# =========================
# 0) Paquetes y datos
# =========================

library(ABM)
library(dplyr)     # para crear columna derivadas
library(ggplot2)
library(readxl)

# Leer base real
hogares <- read_excel("hogares.xlsx")

head(hogares)


# =========================
# 1) ParÃ¡metros y diseÃ±o del programa de transferencias
# =========================

poverty_line <- 4000    # umbral de ingreso del hogar para ser elegible (4500).
                        # Hogares con ingreso menor a ese monto son beneficiarios potenciales
lambda_cred  <- 0.10    # velocidad de aprendizaje o memoria en esa credibilidad.
                        # Controla quÃ© tanto se ajusta la confianza segÃºn la experiencia reciente:
                        # - Si lambda_cred = 1, el hogar olvida todo el pasado y solo cuenta el Ãºltimo pago.
                        # - Si lambda_cred = 0, nunca cambia su credibilidad (memoria infinita).
                        # - 0.30 significa que se ajusta 30% a lo nuevo y conserva 70% del valor anterior.
delay_prob_base <- 0.30 # probabilidad base de que el pago del programa llegue tarde (30%).
cost_school <- 100       # costo promedio mensual de asistir a la escuela (transporte, materiales, etc.)


season_vec <- c(              # Estacionalidad y polÃ­tica de puntualidad pÃºblica. Efectos estacionales por mes (enero..diciembre)
  0.00,  0.00, -0.03, -0.03,  # ene, feb, mar, abr
  0.00,  0.02,  0.02,  0.00,  # may, jun, jul, ago
  -0.02, -0.02,  0.00,  0.00  # sep, oct, nov, dic
)

# Es un vector de 12 nÃºmeros, uno por mes (enero a diciembre).
# Cada nÃºmero es un ajuste en puntos de probabilidad sobre la puntualidad del programa ese mes.
# -0.03 = restar 3 puntos porcentuales a la puntualidad.
# +0.02 = sumar 2 puntos porcentuales.
# 0.00 = sin cambio estacional.


# =========================
# 2) ConstrucciÃ³n de variables derivadas (heterogeneidad inicial)
# =========================

hogares <- hogares %>%
  mutate(
    elegible = ingreso_hogar < poverty_line,               # Nueva columna lÃ³gica (TRUE/FALSE): se elige por ingreso comparado con poverty_line.
    cred0    = 1 - delay_prob_base,                        # el hogar arranca creyendo que 70% de las veces el pago llega puntual.
    theta    = ifelse(zona == "rural",
                      rnorm(n(), mean = 350, sd = 80),     # Umbral de decisiÃ³n heterogÃ©neo (theta) por zona: Si zona: rural (media 250), sino urbana/otra (media 200)
                      rnorm(n(), mean = 200, sd = 80)),
    salario_pot = exp(log(100) + 0.08 * edad + 0.12 * grado + rnorm(n(), 0, 0.2)),       # Salario potencial estimado con un modelo tipo Mincer
    state0 = sample(c("E", "ET", "T"), n(), prob = c(0.4, 0.3, 0.3), replace = TRUE)     # Estado inicial (E 40%, ET 30%, T 30%)
  )

head(hogares)

# Objeto hogares ahora tiene columnas adicionales:
# - elegible (TRUE/FALSE),
# - cred0 (num, 0.7),
# - theta (num, dep. de zona),
# - salario_pot (num, log-normal segÃºn edad/grado),
# - state0 (factor/char con E/ET/T)
# Estas columnas no simulan nada aÃºn; solo preparan la heterogeneidad inicial que luego usarÃ¡ tu simulaciÃ³n ABM (en el tick_handler) para decidir mes a mes.

# Las cargas a cada agente con setState(...).
# El tick_handler las usa para calcular utilidades y actualizar el estado/credibilidad mes a mes.


# =========================
# 3) Crear simulaciÃ³n usando tu base
# =========================
N <- nrow(hogares)            # Define cuÃ¡ntos agentes habrÃ¡ en el mundo simulado (uno por fila de hogares, en esta versiÃ³n).
Tmax <- 36                    # NÃºmero de pasos de tiempo (meses) que correrÃ¡ la simulaciÃ³n.
sim <- Simulation$new(N)      # Crea el objeto simulaciÃ³n con capacidad para N agentes.

for (i in 1:N) {              # Inicia un bucle que va del agente 1 al N. i es el Ã­ndice del agente (ID interno en sim)
  sim$setState(               # Asigna el estado y atributos del agente i.
    i,
    list(
      hogares$state0[i],
      theta   = hogares$theta[i], # Si el dato ya existe en una columna con N filas, necesitas [i].
      cred    = hogares$cred0[i],
      n_hijos = hogares$n_hijos[i],
      Y_hogar = hogares$ingreso_hogar[i],
      elegible = hogares$elegible[i],
      edad     = hogares$edad[i],
      grado    = hogares$grado[i],
      salario  = hogares$salario_pot[i],
      zona     = hogares$zona[i],
      sexo     = hogares$sexo[i]
    )
  )
}

# Importante: aquÃ­ no hay dinÃ¡mica todavÃ­a. Solo estamos instalando el agente con su estado y mochila de atributos. 
# La dinÃ¡mica vendrÃ¡ luego en tu tick_handler (donde mes a mes cambias estado, actualizas cred, etc.).


# =========================
# 4) DinÃ¡mica mensual
# =========================

# p_public: Cada mes es quÃ© tan puntual fue el programa ese mes en promedio, un nÃºmero entre 0 y 1, donde 1 = 100% puntual.
# Ese nÃºmero sale de sumar cuatro ideas:
# - Nivel base: lo normal del programa si nada cambia (por ejemplo, 0.70 si suele cumplir 70%).
# - Estacionalidad (season_vec): meses donde es peor (resta puntos) o mejor (suma puntos) por razones del calendario.
# - PolÃ­tica puntual (policy_eff): una mejora temporal (por ejemplo, durante 4 meses sube 10 puntos porcentuales).
# - Ruido del mes (shock_eff): lo impredecible (un poquito para arriba o abajo).
# DespuÃ©s se recortas a que quede entre 0 y 1 (para que siga siendo una probabilidad vÃ¡lida).

# MÃ¡s tarde, cada hogar puede percibir esa puntualidad con un ajuste (ej. rural percibe 5 p.p. menos).

tick_handler <- function(time, sim, agent) {      # Esta funciÃ³n se ejecutarÃ¡ una vez por cada unidad de tiempo (tick) en la simulaciÃ³n. El modelo ABM la volverÃ¡ a llamar automÃ¡ticamente en cada paso.
                                                  # recibe tres cosas: time: el mes actual (0, 1, 2, â€¦, 36), sim: el objeto de simulaciÃ³n (donde viven los agentes), agent: el programador interno del motor (para reagendar el siguiente tick).
  t <- as.integer(time)                                  # asegura que sea entero
    season_eff <- season_vec[(t %% 12) + 1]              # Estacionalidad segÃºn el mes (repite cada 12 ticks)
    policy_eff <- if (t >= 12 && t <= 15) 0.10 else 0    # Ventana de mejora (ej. meses 12â€“15 sube 10 p.p.)
    shock_eff <- rnorm(1, mean = 0, sd = 0.02)           # Ruido aleatorio (variaciÃ³n natural)
    base_pub <- 1 - delay_prob_base                      # Puntualidad pÃºblica del mes (en [0,1])
    p_public_tick <- max(0, min(1, base_pub + season_eff + policy_eff + shock_eff))
  
  for (i in 1:N) {                                # recorre los N hogares.
    ai <- getAgent(sim, i)                        # trae al agente i. Obtiene todos sus atributos guardados (estado, cred, edad, n_hijos, etc.).
    st <- getState(ai)                            # el nombre de una variable para guardar lo que devuelve getState(ai)
    
    # ai el agente que estoy manipulando
    # st los datos actuales de ese agente
    
    # puntualidad percibida por el hogar (usa el valor del mes y ajusta por zona - 5%)
    p_public <- if (st$zona == "rural") max(0, min(1, p_public_tick - 0.25)) else p_public_tick
    
    # ----- CÃ¡lculo del beneficio -----
    #       Beneficio por hijx si elegible
    hijos_cubiertos <- min(st$n_hijos, 2)     # Calcula cuÃ¡ntos hijxs reciben la transferencia (mÃ¡ximo 2).
    transfer_eff    <- if (st$elegible) 300 * hijos_cubiertos else 0   # Si el hogar es elegible, recibe 500 * hijos_cubiertos; si no, 0. Representa el monto mensual efectivo del apoyo.

    # ----- CÃ¡lculo del salario potencial del niÃ±x -----
    #       salario potencial del niÃ±x (modelo tipo Mincer)
    w_child <- st$salario
    
    # ----- Utilidades de las tres opciones -----
    # utilidades de tres opciones (E=solo escuela, ET=escuela y trabajo, T=solo trabajo)    
    U_E  <- (transfer_eff * st$cred) - cost_school   -   st$theta
    # E (solo escuela): recibe toda la transferencia esperada (ajustada por credibilidad),
    # paga el costo completo de asistir (cost_school),
    # y enfrenta toda la barrera de asistencia (theta), que es mayor en zonas rurales.
    U_ET <- (transfer_eff/2) + (w_child * 0.5) - (cost_school/2)  - (0.5*st$theta)  
    # ET (escuela + trabajo): combina ambas actividades a medio tiempo.
    # Recibe solo la mitad de la transferencia (por asistencia parcial),
    # gana la mitad del salario (media jornada laboral),
    # paga la mitad del costo escolar,
    # y enfrenta solo la mitad de la barrera (theta), 
    # pues asiste parcialmente a la escuela y su logÃ­stica es menos exigente.
    U_T  <- w_child
    # T (solo trabajo): no recibe transferencia ni paga costo escolar,
    # pero obtiene todo el salario potencial del trabajo.
    
    # ----- DecisiÃ³n del hogar -----
    # ðŸ’” ELIMINADO: utilities <- c(E = U_E, ET = U_ET, T = U_T)  # junta las tres utilidades en un vector.
    # ðŸ’” ELIMINADO: new_state <- names(which.max(utilities))     # elige el estado que tenga la utilidad mÃ¡s alta (la mejor decisiÃ³n econÃ³mica para ese hogar). which.max() da la posiciÃ³n; names() extrae E, ET o T
    
   #  ---------------  Idea intuitiva
   #                   Con which.max(utilities) siempre gana la utilidad mÃ¡s alta: todos los hogares actÃºan igual ante los mismos incentivos. El sistema se congela.
   #                   En la realidad hay gustos no observados, fricciones e informaciÃ³n imperfecta.
   #                   Modelamos eso como un ruido aleatorio (tipo Gumbel). El resultado es que cada opciÃ³n (E, ET, T) tiene una probabilidad de ser elegida.
   #                   Antes (argmax): which.max(utilities) siempre elige la opciÃ³n con el nÃºmero mÃ¡s grande. Resultado: todos hacen lo mismo y el modelo se congela.
   #                   Ahora (softmax): si una opciÃ³n tiene un nÃºmero mÃ¡s grande, tiene mÃ¡s chance, pero las otras no quedan en cero.
   #                   Resultado: hay probabilidades y, por lo tanto, movimiento entre E / ET / T.
   #          quÃ© es tau (la temperatura):quÃ© tanto permites salirse del Ã³ptimo:
   #          - tau chico:  casi siempre gana la mejor (se parece al argmax).
   #          - tau grande: mÃ¡s mezcla; las segundas mejores tambiÃ©n se eligen a veces.
    
   
   utilities <- c(E = U_E, ET = U_ET, T = U_T) # utilidades determinÃ­sticas ya calculadas (juntas en un vector las tres utilidades que calculaste para este hogar en este mes)
    
   
   tau <- 200  # temperatura/margen de error/tolerancia al cambio:
               # se ajusta en pesos por ejemplo. Controla cuÃ¡nta aleatoriedad permites:
    
   
   u_center <- utilities - max(utilities) # estabilidad numÃ©rica: restar la mayor utilidad antes de exp. 
                                          # Las utilidades pueden ser grandes (por ejemplo, 20000 pesos).
                                          # Al aplicar una exponencial (exp()), esos nÃºmeros se disparan.
                                          # Entonces, restar el mÃ¡ximo solo centra los valores:
    
   probs <- exp(u_center / tau)           # Convierte utilidades en pesos positivos con exp(â€¦/tau).
                                          # toma cada utilidad centrada (u_center) y la transforma en un peso positivo usando la exponencial.
                                          # Por quÃ© exponencial: garantiza que todos los pesos sean > 0 (nunca negativos). 
                                          # AdemÃ¡s, una utilidad un poco mayor se vuelve mucho mayor tras exp, asÃ­ que las opciones mejores reciben mÃ¡s peso.
                                          # Rol de tau: es la temperatura. Divide las utilidades para suavizar o acentuar diferencias:
                                          # - tau grande - > diferencias se achican - > pesos mÃ¡s parecidos.
                                          # - tau chico - > diferencias se agrandan -> el peso de la mejor domina.
   
   probs <- probs / sum(probs)            # convierte esos pesos en probabilidades dividiendo por su suma.
                                          # Resultado de ahora sum(probs) = 1, y cada probs[j] estÃ¡ entre 0 y 1 - > ya son probabilidades vÃ¡lidas.
                                          # La opciÃ³n con mayor utilidad tenÃ­a el mayor peso exp, y al normalizar sigue con la probabilidad mÃ¡s alta, 
                                          # pero las demÃ¡s no quedan en cero. 
    
  
   new_state <- sample(c("E","ET","T"), size = 1, prob = probs)  # elecciÃ³n segÃºn esas probabilidades
    
    
    # ----- Ver si el pago llegÃ³ a tiempo -----
    # NUEVO: Actualizar credibilidad solo si el hogar participa Y es elegible (observa su propio pago)
   if (new_state %in% c("E","ET") && st$elegible) {
    # Caso 1: El hogar participa y es elegible - > observa su propio pago
    # La puntualidad individual depende de la puntualidad pÃºblica del mes y un sorteo individual
     paid_on_time <- runif(1) < p_public
     cred_new <- (1 - lambda_cred) * st$cred + lambda_cred * as.numeric(paid_on_time)
    } else {
    # Caso 2: No participa o no es elegible - > no observa pago directo
    # Aprende de la seÃ±al pÃºblica del mes (p_public_tick), que representa el desempeÃ±o general del programa
      cred_new <- (1 - lambda_cred) * st$cred + lambda_cred * p_public_tick
    }
  
  # Si no participa o no es elegible, su credibilidad se actualiza segÃºn una seÃ±al pÃºblica promedio, 
  # AsÃ­, la credibilidad no colapsa a cero, sino que refleja la percepciÃ³n colectiva del programa.
    
    # ----- Guardar nuevo estado y atributos -----
    #       Toma al agente que se esta actualizando (ai).
    #       Le guarda su nuevo estado y sus atributos en la simulaciÃ³n.
    
    setState(ai, list(
      new_state,
      theta   = st$theta,
      cred    = cred_new,
      n_hijos = st$n_hijos,
      Y_hogar = st$Y_hogar,
      elegible = st$elegible,
      edad = st$edad,
      grado = st$grado,
      salario = st$salario,
      zona = st$zona,
      sexo = st$sexo
    ))
  }
  
  if (time < Tmax) schedule(agent, newEvent(time + 1, tick_handler))
}


# =========================
# 5) Ejecutar
# =========================
sim$addLogger(newCounter("E", "E"))     # Solo escuela  1) columna "E"   2) cuenta agentes en estado "E"
sim$addLogger(newCounter("ET", "ET"))   # Escuela + trabajo
sim$addLogger(newCounter("T", "T"))     # Solo trabajo

# Los tres newCounter dan, en cada mes, cuÃ¡ntos hogares estÃ¡n en solo escuela (E), escuela+trabajo (ET) y solo trabajo (T), 
# y esa serie queda guardada en res para graficar o analizar.

schedule(sim$get, newEvent(0, tick_handler))  # esta lÃ­nea arranca la simulaciÃ³n: es como presionar el botÃ³n play
res <- sim$run(0:Tmax)                        # sim$run() ejecuta todos los eventos que fueron programados
res$attend <- (res$E + res$ET) / N            # Crea una nueva columna en res llamada attend (asistencia): ProporciÃ³n que estudia (solo escuela o escuela+trabajo)


res

# =========================
# 6) Graficar
# =========================
ggplot(res, aes(x = times, y = attend)) +
  geom_line(size = 1.3, color = "darkorange") +
  geom_area(alpha = 0.15, fill = "gold") +
  coord_cartesian(ylim = c(0, 1)) +
  labs(title = "Asistencia simulada con base real de hogares",
       x = "Mes", y = "% hogares con niÃ±xs en escuela") +
  theme_minimal(base_size = 14)

